const applicationSchema = z.object({
  id: z.number(),
  studentId: z.string().uuid(),
  driveId: z.number(),
  appliedAt: z.string(),
  student: z.object({
    name: z.string().nullable(),
    email: z.string(),
    studentId: z.string().uuid(),
    phoneNumber: z.number().nullable(),
    batch: z.number().nullable(), // Assuming year as batch
    regNo: z.string().nullable(),
    department: z.string().nullable(),
    rollNo: z.number().nullable(),
    placedStatus: z.enum(["yes", "no"]).nullable(),
    cgpa: z.number().nullable(),
  }),
});

const jobSchema = z.object({
  id: z.number(),
  createdAt: z.string(),
  companyName: z.string(),
  jobDescription: z.string(),
  driveDate: z.string(),
  expiration: z.string(),
  batch: z.string(),
  department: z.array(z.string()),
  applications: z.array(applicationSchema),
});

export const getJobs = createRoute({
  path: "/superadmin/jobs",
  method: "get",
  responses: {
    [HttpStatusCodes.OK]: jsonContent(
      z.object({ success: z.boolean(), jobs: z.array(jobSchema) }),
      "List of all jobs with registered students"
    ),
    [HttpStatusCodes.UNAUTHORIZED]: jsonContent(
      createErrorSchema(z.object({})),
      "Unauthorized access"
    ),
  },
  middlewares: [supabaseMiddleware],
});
























































export const getJobs: AppRouteHandler<GetJobsRoute> = async (c) => {
  const jwtToken = getCookie(c, "admin_session") || getCookie(c, "oauth_session");
  if (!jwtToken) {
    return c.json({ error: "Unauthorized: No session found" }, 401);
  }

  const SECRET_KEY = process.env.SECRET_KEY;
  if (!SECRET_KEY) {
    console.error("SECRET_KEY is not defined in environment variables");
    return c.json({ error: "Server configuration error" }, 500);
  }

  try {
    const decoded = await verify(jwtToken, SECRET_KEY);
    if (!decoded || decoded.role !== "super_admin") {
      return c.json({ error: "Unauthorized: Insufficient role" }, 403);
    }

    // Fetch jobs with applications and extended student details
    const jobData = await db
      .select({
        driveId: drive.id,
        createdAt: drive.createdAt,
        companyName: drive.companyName,
        jobDescription: drive.jobDescription,
        driveDate: drive.driveDate,
        expiration: drive.expiration,
        batch: drive.batch,
        department: drive.department,
        applicationId: applications.id,
        studentId: applications.studentId,
        appliedAt: applications.appliedAt,
        studentName: students.name,
        studentEmail: students.email,
        studentStudentId: students.studentId,
        studentPhoneNumber: students.phoneNumber,
        studentBatch: students.year, // Assuming 'year' maps to student batch
        studentRegNo: students.regNo,
        studentDepartment: students.department,
        studentRollNo: students.rollNo,
        studentPlacedStatus: students.placedStatus,
        studentCgpa: students.cgpa,
      })
      .from(drive)
      .leftJoin(applications, eq(drive.id, applications.driveId))
      .leftJoin(students, eq(applications.studentId, students.studentId))
      .execute();

    console.log("Raw job data from DB:", jobData); // Debug raw output

    // Group applications by job
    const jobMap = new Map();
    jobData.forEach((row) => {
      if (!jobMap.has(row.driveId)) {
        jobMap.set(row.driveId, {
          id: row.driveId,
          createdAt: row.createdAt,
          companyName: row.companyName,
          jobDescription: row.jobDescription,
          driveDate: row.driveDate,
          expiration: row.expiration,
          batch: row.batch,
          department: row.department,
          applications: [],
        });
      }
      if (row.studentId) {
        jobMap.get(row.driveId).applications.push({
          id: row.applicationId,
          studentId: row.studentId,
          driveId: row.driveId,
          appliedAt: row.appliedAt,
          student: {
            name: row.studentName,
            email: row.studentEmail,
            studentId: row.studentStudentId,
            phoneNumber: row.studentPhoneNumber,
            batch: row.studentBatch, // Mapping 'year' to batch
            regNo: row.studentRegNo,
            department: row.studentDepartment,
            rollNo: row.studentRollNo,
            placedStatus: row.studentPlacedStatus,
            cgpa: row.studentCgpa,
          },
        });
      }
    });

    const jobs = Array.from(jobMap.values());
    console.log("Processed jobs with applications:", jobs); // Debug final output

    return c.json({ success: true, jobs }, 200);
  } catch (error) {
    console.error("Detailed error fetching jobs:", error.stack || error.message);
    return c.json({ error: "Failed to fetch jobs", details: error.message }, 500);
  }
};